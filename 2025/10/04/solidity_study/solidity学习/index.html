<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这是文章开头，显示在主页面，详情请点击此处。">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity学习">
<meta property="og:url" content="http://example.com/2025/10/04/solidity_study/solidity%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Tiger_pop&#39;s Blog">
<meta property="og:description" content="这是文章开头，显示在主页面，详情请点击此处。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-04T02:27:21.000Z">
<meta property="article:modified_time" content="2025-10-16T10:08:35.252Z">
<meta property="article:author" content="陈宇韶chenyushao">
<meta property="article:tag" content="solidity">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/04/solidity_study/solidity%E5%AD%A6%E4%B9%A0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/04/solidity_study/solidity%E5%AD%A6%E4%B9%A0/","path":"2025/10/04/solidity_study/solidity学习/","title":"solidity学习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>solidity学习 | Tiger_pop's Blog</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Tiger_pop's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Tiger_pop's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">tiger_pop 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.</span> <span class="nav-text">几个实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E4%B8%BE"><span class="nav-number">1.1.</span> <span class="nav-text">选举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%AB%9E%E6%8B%8D"><span class="nav-number">1.2.</span> <span class="nav-text">普通竞拍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9D%E6%A3%80%E6%9F%A5-%E7%94%9F%E6%95%88-%E4%BA%A4%E4%BA%92%E2%80%9D-%E5%8E%9F%E5%88%99"><span class="nav-number">1.3.</span> <span class="nav-text">**”检查-生效-交互”**原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B2%E6%8B%8D"><span class="nav-number">1.4.</span> <span class="nav-text">盲拍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E8%B4%AD%E4%B9%B0"><span class="nav-number">1.5.</span> <span class="nav-text">远程购买</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%94%AF%E4%BB%98%E9%80%9A%E9%81%93"><span class="nav-number">1.6.</span> <span class="nav-text">微支付通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E9%80%9A%E4%BF%97%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E6%96%B0%E4%BA%BA%E5%BF%85%E7%9C%8B%EF%BC%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">（一）通俗的例子（新人必看）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%AA%99-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%BC%80%E9%80%9A%E9%80%9A%E9%81%93%EF%BC%88%E4%B8%8A%E9%93%BE%EF%BC%89"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">🪙 第一步：开通通道（上链）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9C%8D%EF%B8%8F-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E7%A6%BB%E7%BA%BF%E7%AD%BE%E5%90%8D%EF%BC%88%E7%A6%BB%E9%93%BE%E6%94%AF%E4%BB%98%EF%BC%89"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">✍️ 第二步：离线签名（离链支付）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%94%90-%E2%80%9C%E7%AD%BE%E7%BD%B2%E5%86%85%E5%AE%B9%E2%80%9D%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">🔐 “签署内容”到底是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%92%A1-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E9%80%9A%E9%81%93%E7%BB%93%E7%AE%97%EF%BC%88%E4%B8%8A%E9%93%BE%E4%B8%80%E6%AC%A1%EF%BC%89"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">💡 第三步：通道结算（上链一次）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%98%E7%BD%91%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.6.2.</span> <span class="nav-text">（二）官网的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AD%BE%E5%90%8D"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">创建签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%BE%E7%BD%B2%E5%86%85%E5%AE%B9"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">签署内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E8%A3%85%E5%8F%82%E6%95%B0"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">组装参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Solidity%E4%B8%AD%E6%81%A2%E5%A4%8D%E4%BF%A1%E6%81%AF%E7%AD%BE%E5%90%8D%E8%80%85"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">在Solidity中恢复信息签名者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈宇韶chenyushao"
      src="/images/my.jpg">
  <p class="site-author-name" itemprop="name">陈宇韶chenyushao</p>
  <div class="site-description" itemprop="description">爱学习、爱工作、爱生活;         微信号: Tiger_and_master;         手机号码:18515678348 </div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">427</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">201</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/04/solidity_study/solidity%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.jpg">
      <meta itemprop="name" content="陈宇韶chenyushao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiger_pop's Blog">
      <meta itemprop="description" content="爱学习、爱工作、爱生活;         微信号: Tiger_and_master;         手机号码:18515678348 ">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="solidity学习 | Tiger_pop's Blog">
      <meta itemprop="description" content="这是文章开头，显示在主页面，详情请点击此处。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          solidity学习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-04 10:27:21" itemprop="dateCreated datePublished" datetime="2025-10-04T10:27:21+08:00">2025-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-16 18:08:35" itemprop="dateModified" datetime="2025-10-16T18:08:35+08:00">2025-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">这是文章开头，显示在主页面，详情请点击此处。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>solidity文档 <code>https://learnblockchain.cn/docs/solidity/</code></p>
<h1 id="几个实例"><a href="#几个实例" class="headerlink" title="几个实例"></a>几个实例</h1><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">/// @title 委托投票</span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    // 这里声明了一个新的复合类型用于稍后的变量。</span><br><span class="line">    // 该变量用来表示一个选民。</span><br><span class="line">    struct Voter &#123;</span><br><span class="line">        uint weight; // 计票的权重</span><br><span class="line">        bool voted;  // 若为真，代表该人已投票</span><br><span class="line">        address delegate; // 被委托人</span><br><span class="line">        uint vote;   // 投票提案的索引</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提案的类型.</span><br><span class="line">    struct Proposal &#123;</span><br><span class="line">        bytes32 name;   // 简称（最长32个字节）</span><br><span class="line">        uint voteCount; // 得票数  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address public chairperson;</span><br><span class="line"></span><br><span class="line">    // 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。</span><br><span class="line">    mapping(address =&gt; Voter) public voters;</span><br><span class="line"></span><br><span class="line">    // 一个 `Proposal` 结构类型的动态数组</span><br><span class="line">    Proposal[] public proposals;</span><br><span class="line"></span><br><span class="line">    /// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决 memory 表示 从临时内存中读取，就是 获取外部输入。 </span><br><span class="line">    constructor(bytes32[] memory proposalNames) &#123;  // 这里用 memory 临时用一下，但是proposals.push 会让内容保存到永久 storage中。 </span><br><span class="line">        chairperson = msg.sender;                  // msg.sender 是调用合约者（消息发送者）自己的地址。</span><br><span class="line">        voters[chairperson].weight = 1;</span><br><span class="line"></span><br><span class="line">        //对于提供的每个提案名称，</span><br><span class="line">        //创建一个新的 Proposal 对象并把它添加到数组的末尾。</span><br><span class="line">        for (uint i = 0; i &lt; proposalNames.length; i++) &#123;</span><br><span class="line">            // `Proposal(&#123;...&#125;)` 创建一个临时 Proposal 对象，</span><br><span class="line">            // `proposals.push(...)` 将其添加到 `proposals` 的末尾</span><br><span class="line">            proposals.push(Proposal(&#123;</span><br><span class="line">                name: proposalNames[i],</span><br><span class="line">                voteCount: 0</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 授权 `voter` 对这个（投票）表决进行投票。</span><br><span class="line">    // 只有 `chairperson` 可以调用该函数。</span><br><span class="line">    function giveRightToVote(address voter) external &#123;</span><br><span class="line">        // 若 `require` 的第一个参数的计算结果为 `false`，</span><br><span class="line">        // 则终止执行，撤销所有对状态和以太币余额的改动。</span><br><span class="line">        // 在旧版的 EVM 中这曾经会消耗所有 gas，但现在不会了。</span><br><span class="line">        // 使用 require 来检查函数是否被正确地调用，是一个好习惯。</span><br><span class="line">        // 你也可以在 require 的第二个参数中提供一个对错误情况的解释。</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == chairperson,</span><br><span class="line">            &quot;Only chairperson can give right to vote.&quot;</span><br><span class="line">        );</span><br><span class="line">        require(</span><br><span class="line">            !voters[voter].voted,</span><br><span class="line">            &quot;The voter already voted.&quot;</span><br><span class="line">        );</span><br><span class="line">        require(voters[voter].weight == 0);  // 避免 重复授权 ，这样无意义。 </span><br><span class="line">        voters[voter].weight = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 把你的投票委托到投票者 `to`。</span><br><span class="line">    function delegate(address to) external &#123;</span><br><span class="line">        // 传引用</span><br><span class="line">        Voter storage sender = voters[msg.sender];  //storage → &quot;修改永久状态&quot;后续操作直接修改区块链状态；memory → &quot;我只需要临时计算&quot;</span><br><span class="line">        require(sender.weight != 0, &quot;You have no right to vote&quot;);</span><br><span class="line">        require(!sender.voted, &quot;You already voted.&quot;);</span><br><span class="line"></span><br><span class="line">        require(to != msg.sender, &quot;Self-delegation is disallowed.&quot;);</span><br><span class="line"></span><br><span class="line">        // 委托是可以传递的，只要被委托者 `to` 也设置了委托。</span><br><span class="line">        // 一般来说，这种循环委托是危险的。因为，如果传递的链条太长，</span><br><span class="line">        // 则可能需消耗的gas要多于区块中剩余的（大于区块设置的gasLimit），</span><br><span class="line">        // 这种情况下，委托不会被执行。</span><br><span class="line">        // 而在另一些情况下，如果形成闭环，则会让合约完全卡住。</span><br><span class="line">        while (voters[to].delegate != address(0)) &#123;  // 找到 委托链的最后一个委托者，address(0)指的是 null类似于委托链的终点。</span><br><span class="line">            to = voters[to].delegate;</span><br><span class="line"></span><br><span class="line">            // 不允许闭环委托</span><br><span class="line">            require(to != msg.sender, &quot;Found loop in delegation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Voter storage delegate_ = voters[to];      // 最终委托者 （最终投票者）</span><br><span class="line"></span><br><span class="line">        // Voters cannot delegate to accounts that cannot vote.</span><br><span class="line">        require(delegate_.weight &gt;= 1);</span><br><span class="line"></span><br><span class="line">        // Since `sender` is a reference, this</span><br><span class="line">        // modifies `voters[msg.sender]`.</span><br><span class="line">        sender.voted = true;</span><br><span class="line">        sender.delegate = to;</span><br><span class="line"></span><br><span class="line">        if (delegate_.voted) &#123;</span><br><span class="line">            // 若被委托者已经投过票了，直接增加得票数</span><br><span class="line">            proposals[delegate_.vote].voteCount += sender.weight;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 若被委托者还没投票，增加委托者的权重</span><br><span class="line">            delegate_.weight += sender.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 把你的票(包括委托给你的票)，</span><br><span class="line">    /// 投给提案 `proposals[proposal].name`.</span><br><span class="line">    function vote(uint proposal) external &#123;</span><br><span class="line">        Voter storage sender = voters[msg.sender];</span><br><span class="line">        require(sender.weight != 0, &quot;Has no right to vote&quot;);</span><br><span class="line">        require(!sender.voted, &quot;Already voted.&quot;);</span><br><span class="line">        sender.voted = true;</span><br><span class="line">        sender.vote = proposal;</span><br><span class="line"></span><br><span class="line">        // 如果 `proposal` 超过了数组的范围，则会自动抛出异常，并恢复所有的改动</span><br><span class="line"></span><br><span class="line">        proposals[proposal].voteCount += sender.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @dev 结合之前所有的投票，计算出最终胜出的提案 ，view 只读不修改状态，免gas费。</span><br><span class="line">    function winningProposal() public view  </span><br><span class="line">            returns (uint winningProposal_)    </span><br><span class="line">    &#123;</span><br><span class="line">        uint winningVoteCount = 0;</span><br><span class="line">        for (uint p = 0; p &lt; proposals.length; p++) &#123;</span><br><span class="line">            if (proposals[p].voteCount &gt; winningVoteCount) &#123;</span><br><span class="line">                winningVoteCount = proposals[p].voteCount;</span><br><span class="line">                winningProposal_ = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称</span><br><span class="line">    function winnerName() external view</span><br><span class="line">            returns (bytes32 winnerName_)</span><br><span class="line">    &#123;</span><br><span class="line">        winnerName_ = proposals[winningProposal()].name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="普通竞拍"><a href="#普通竞拍" class="headerlink" title="普通竞拍"></a>普通竞拍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    // 拍卖的参数。时间可以是绝对的 unix 时间戳（自 1970-01-01 起的秒数）或以秒为单位的时间段。</span><br><span class="line">    address payable public beneficiary;  // 标记该地址能够接收资金</span><br><span class="line">    uint public auctionEndTime;</span><br><span class="line"></span><br><span class="line">    // 拍卖的当前状态。</span><br><span class="line">    address public highestBidder;</span><br><span class="line">    uint public highestBid;</span><br><span class="line"></span><br><span class="line">    // 允许取回的先前出价</span><br><span class="line">    mapping(address =&gt; uint) pendingReturns;</span><br><span class="line"></span><br><span class="line">    // 在结束时设置为 true，禁止任何更改。</span><br><span class="line">    // 默认初始化为 `false`。</span><br><span class="line">    bool ended;</span><br><span class="line"></span><br><span class="line">    // 变更触发的事件。 事件就是区块链的&quot;广播系统&quot;，广播内容为参数内容。</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount);</span><br><span class="line">    event AuctionEnded(address winner, uint amount);</span><br><span class="line"></span><br><span class="line">    // Errors 用来定义失败</span><br><span class="line"></span><br><span class="line">    // 三斜杠注释是所谓的 natspec 注释。</span><br><span class="line">    // 当用户被要求确认交易时将显示它们，或者当显示错误时。</span><br><span class="line"></span><br><span class="line">    /// 拍卖已经结束。</span><br><span class="line">    error AuctionAlreadyEnded();  // revert 交易回滚​ gas 退回；</span><br><span class="line">    /// 已经有更高或相等的出价。</span><br><span class="line">    error BidNotHighEnough(uint highestBid);</span><br><span class="line">    /// 拍卖尚未结束。</span><br><span class="line">    error AuctionNotYetEnded();</span><br><span class="line">    /// 函数 auctionEnd 已经被调用。</span><br><span class="line">    error AuctionEndAlreadyCalled();</span><br><span class="line"></span><br><span class="line">    /// 创建一个简单的拍卖，拍卖时间为 `biddingTime`秒，代表受益人地址 `beneficiaryAddress`。</span><br><span class="line">    constructor(</span><br><span class="line">        uint biddingTime,</span><br><span class="line">        address payable beneficiaryAddress</span><br><span class="line">    ) &#123;</span><br><span class="line">        beneficiary = beneficiaryAddress;</span><br><span class="line">        auctionEndTime = block.timestamp + biddingTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 在拍卖中出价，出价的值与此交易一起发送。</span><br><span class="line">    /// 该值仅在拍卖未获胜时退款。</span><br><span class="line">    function bid() external payable &#123;</span><br><span class="line">        // 不需要参数，所有信息已经是交易的一部分。</span><br><span class="line">        // 关键字 payable 是必需的，以便函数能够接收以太。</span><br><span class="line"></span><br><span class="line">        // 如果拍卖时间已过，则撤销调用。</span><br><span class="line">        if (block.timestamp &gt; auctionEndTime)</span><br><span class="line">            revert AuctionAlreadyEnded();</span><br><span class="line"></span><br><span class="line">        // 如果出价不高，则将以太币退回（撤销语句将撤销此函数执行中的所有更改，包括它已接收以太币）。</span><br><span class="line">        if (msg.value &lt;= highestBid)</span><br><span class="line">            revert BidNotHighEnough(highestBid);</span><br><span class="line"></span><br><span class="line">        if (highestBid != 0) &#123;</span><br><span class="line">            // 通过简单使用 highestBidder.send(highestBid) 退回以太币是一个安全风险，因为它可能会执行一个不受信任的合约。</span><br><span class="line">            // 让接收者自行提取他们的以太币总是更安全。</span><br><span class="line">            pendingReturns[highestBidder] += highestBid;</span><br><span class="line">        &#125;</span><br><span class="line">        highestBidder = msg.sender;</span><br><span class="line">        highestBid = msg.value;</span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 取回出价（当该出价已被超越）</span><br><span class="line">    function withdraw() external returns (bool) &#123;</span><br><span class="line">        uint amount = pendingReturns[msg.sender];</span><br><span class="line">        if (amount &gt; 0) &#123;</span><br><span class="line">            // 将其设置为零很重要，因为接收者可以在 `send` 返回之前再次调用此函数作为接收调用的一部分。</span><br><span class="line">            pendingReturns[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">            // msg.sender 不是 `address payable` 类型，必须显式转换为 `payable(msg.sender)` 以便使用成员函数 `send()`。</span><br><span class="line">            if (!payable(msg.sender).send(amount)) &#123;</span><br><span class="line">                // 这里不需要调用 throw，只需重置未付款</span><br><span class="line">                pendingReturns[msg.sender] = amount;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 结束拍卖并将最高出价发送给受益人。</span><br><span class="line">    function auctionEnd() external &#123;</span><br><span class="line">        // 这是一个好的指导原则，将与其他合约交互的函数（即它们调用函数或发送以太）结构化为三个阶段：</span><br><span class="line">        // 1. 检查条件</span><br><span class="line">        // 2. 执行操作（可能更改条件）</span><br><span class="line">        // 3. 与其他合约交互</span><br><span class="line">        // 如果这些阶段混合在一起，其他合约可能会回调当前合约并修改状态或导致效果（以太支付）被多次执行。</span><br><span class="line">        // 如果内部调用的函数包括与外部合约的交互，它们也必须被视为与外部合约的交互。</span><br><span class="line"></span><br><span class="line">        // 1. 条件</span><br><span class="line">        if (block.timestamp &lt; auctionEndTime)</span><br><span class="line">            revert AuctionNotYetEnded();</span><br><span class="line">        if (ended)</span><br><span class="line">            revert AuctionEndAlreadyCalled();</span><br><span class="line"></span><br><span class="line">        // 2. 生效</span><br><span class="line">        ended = true;</span><br><span class="line">        emit AuctionEnded(highestBidder, highestBid);</span><br><span class="line"></span><br><span class="line">        // 3. 交互</span><br><span class="line">        beneficiary.transfer(highestBid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="”检查-生效-交互”-原则"><a href="#”检查-生效-交互”-原则" class="headerlink" title="**”检查-生效-交互”**原则"></a>**”检查-生效-交互”**原则</h2><p>check、effect、interaction。</p>
<p>如果让 interaction交互 发生在 effect状态变化前面，可能导致<strong>重入攻击</strong>。</p>
<p><strong>重入攻击</strong>就是别人反复调用你的一个函数或者方法，实现攻击的方法。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (highestBid != 0) &#123;</span><br><span class="line">    // 改为直接转账（易受攻击的版本）</span><br><span class="line">    (bool success, ) = highestBidder.call&#123;value: highestBid&#125;(&quot;&quot;);</span><br><span class="line">    require(success, &quot;Transfer failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">highestBidder = msg.sender;</span><br><span class="line">highestBid = msg.value;</span><br><span class="line">emit HighestBidIncreased(msg.sender, msg.value);</span><br></pre></td></tr></table></figure>

<p>interaction交互（向这个地址中转账先发生）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(bool success, ) = highestBidder.call&#123;value: highestBid&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>effect状态后改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">highestBidder = msg.sender;</span><br><span class="line">highestBid = msg.value;</span><br></pre></td></tr></table></figure>

<p>假如此时有一个 黑客合约，（在被别的合约call调用 收款时，会自动 运行receive函数，这是区块链规则），</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    // 在接收以太币时，重新调用 bid 函数，出价略高于当前最高价</span><br><span class="line">    auction.bid&#123;value: currentHighestBid + 1 wei&#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它先出价1eth，别人进价2eth，它就会以之前的最高价被调用<code>highestBidder.call&#123;value: highestBid&#125;(&quot;&quot;)</code>，它在收到1eth退款后，接了一个 重新调用 bid 函数的操作，而且出价仅仅比之前高一点点如1.001eth。由于之前的  effect状态改变还未发生，导致还是之前自己老的出价 1eth作为 <code>highestBid</code> ，自己这高一点点的 新竞价，能够通过 bid中 check 步骤 <code>if (msg.value &lt;= highestBid)</code> 等等这些条件，然后 再度刷新自己之前 最高竞价退款的步骤<code>highestBidder.call&#123;value: highestBid&#125;(&quot;&quot;)</code>,再次收到 1eth的退款，而再次在 黑客合约中调用receive函数，再次收到 1eth的退款，实现递归，直到花光gas 或者在自己写的某个条件停下来。 </p>
<h2 id="盲拍"><a href="#盲拍" class="headerlink" title="盲拍"></a>盲拍</h2><p><strong>具有约束力且保密</strong>：防止竞标者在赢得拍卖后不发送以太币的唯一方法是让他们在出价时一起发送，哈希实现保密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line">contract BlindAuction &#123;</span><br><span class="line">    struct Bid &#123;</span><br><span class="line">        bytes32 blindedBid;</span><br><span class="line">        uint deposit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address payable public beneficiary;</span><br><span class="line">    uint public biddingEnd;</span><br><span class="line">    uint public revealEnd;</span><br><span class="line">    bool public ended;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; Bid[]) public bids;</span><br><span class="line"></span><br><span class="line">    address public highestBidder;</span><br><span class="line">    uint public highestBid;</span><br><span class="line"></span><br><span class="line">    // 允许提取之前出价</span><br><span class="line">    mapping(address =&gt; uint) pendingReturns;</span><br><span class="line"></span><br><span class="line">    event AuctionEnded(address winner, uint highestBid);</span><br><span class="line"></span><br><span class="line">    // Errors 用来定义失败</span><br><span class="line"></span><br><span class="line">    /// 函数被调用得太早。</span><br><span class="line">    /// 请在 `time` 再试一次。</span><br><span class="line">    error TooEarly(uint time);</span><br><span class="line">    /// 函数被调用得太晚。</span><br><span class="line">    /// 不能在 `time` 之后调用。</span><br><span class="line">    error TooLate(uint time);</span><br><span class="line">    /// 函数 auctionEnd 已经被调用。</span><br><span class="line">    error AuctionEndAlreadyCalled();</span><br><span class="line"></span><br><span class="line">    // 修改器是一种方便的方式来验证输入函数。</span><br><span class="line">    // `onlyBefore` 应用于下面的 `bid`：新的函数体是修改器的主体，其中 `_` 被旧函数体替换。</span><br><span class="line">    // solidity 中的 modifier 方法 很像 python中的 @ 后面的装饰器啊，就是一个 对被修饰方法的闭包式的 封装。 </span><br><span class="line">    modifier onlyBefore(uint time) &#123;</span><br><span class="line">        if (block.timestamp &gt;= time) revert TooLate(time);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier onlyAfter(uint time) &#123;</span><br><span class="line">        if (block.timestamp &lt;= time) revert TooEarly(time);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        uint biddingTime,</span><br><span class="line">        uint revealTime,</span><br><span class="line">        address payable beneficiaryAddress</span><br><span class="line">    ) &#123;</span><br><span class="line">        beneficiary = beneficiaryAddress;</span><br><span class="line">        biddingEnd = block.timestamp + biddingTime;</span><br><span class="line">        revealEnd = biddingEnd + revealTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 以 `blindedBid` = keccak256(abi.encodePacked(value, fake, secret)) 的方式提交一个盲出价，它是一个hash值。</span><br><span class="line">    /// 发送的以太币仅在出价在揭示阶段被正确揭示时才会退还。</span><br><span class="line">    /// 如果与出价一起发送的以太币至少为 &quot;value&quot; 且 &quot;fake&quot; 不为真，则出价有效。</span><br><span class="line">    /// 将 &quot;fake&quot; 设置为真并发送不准确的金额是隐藏真实出价的方式，但仍然满足所需的存款。</span><br><span class="line">    /// 相同地址可以提交多个出价。</span><br><span class="line">    // onlyBefore(biddingEnd) 就是 solidity使用前文装饰器的写法。 </span><br><span class="line">    function bid(bytes32 blindedBid)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        onlyBefore(biddingEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        bids[msg.sender].push(Bid(&#123;</span><br><span class="line">            blindedBid: blindedBid,</span><br><span class="line">            deposit: msg.value</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 用户自己来揭示盲出价。</span><br><span class="line">    /// 将获得所有正确盲出的无效出价的退款，以及除了最高出价之外的所有出价。</span><br><span class="line">    // 在 Solidity 中，函数参数有三种存储位置：</span><br><span class="line">    // memory- 易失性内存（可修改）</span><br><span class="line">    // storage- 永久存储（可修改）</span><br><span class="line">    // calldata- 只读调用数据（不可修改）</span><br><span class="line">    function reveal(</span><br><span class="line">        uint[] calldata values,</span><br><span class="line">        bool[] calldata fakes,</span><br><span class="line">        bytes32[] calldata secrets</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">        onlyAfter(biddingEnd)</span><br><span class="line">        onlyBefore(revealEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        uint length = bids[msg.sender].length;</span><br><span class="line">        require(values.length == length);</span><br><span class="line">        require(fakes.length == length);</span><br><span class="line">        require(secrets.length == length);</span><br><span class="line"></span><br><span class="line">        uint refund; // 退款</span><br><span class="line">        for (uint i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            Bid storage bidToCheck = bids[msg.sender][i]; // 公示数据是链上要记录的。</span><br><span class="line">            // 获取用户提交的揭示数据</span><br><span class="line">            (uint value, bool fake, bytes32 secret) =</span><br><span class="line">                    (values[i], fakes[i], secrets[i]);</span><br><span class="line">            if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) &#123;</span><br><span class="line">                // 出价未能正确披露</span><br><span class="line">                // 不退还存款。</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            refund += bidToCheck.deposit;</span><br><span class="line">            // 如果是真实出价且押金&gt;=出价金额</span><br><span class="line">            if (!fake &amp;&amp; bidToCheck.deposit &gt;= value) &#123;</span><br><span class="line">                if (placeBid(msg.sender, value))</span><br><span class="line">                    refund -= value;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使发送者无法重新取回相同的存款。如果没有这一步，用户再调用 reveal函数，又会退一遍，这一步的目的相当于撤销承诺。</span><br><span class="line">            bidToCheck.blindedBid = bytes32(0);</span><br><span class="line">        &#125;</span><br><span class="line">        payable(msg.sender).transfer(refund);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 提取被超出出价的出价。</span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        uint amount = pendingReturns[msg.sender];</span><br><span class="line">        if (amount &gt; 0) &#123;</span><br><span class="line">            // 将其设置为零是重要的，</span><br><span class="line">            // 因为，作为接收调用的一部分，</span><br><span class="line">            // 接收者可以在 `transfer` 返回之前重新调用该函数。（可查看上面关于“条件 -&gt; 生效 -&gt; 交互”的标注）</span><br><span class="line">            pendingReturns[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">            payable(msg.sender).transfer(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 结束拍卖并将最高出价发送给受益人。</span><br><span class="line">    function auctionEnd()</span><br><span class="line">        external</span><br><span class="line">        onlyAfter(revealEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ended) revert AuctionEndAlreadyCalled(); // ended 在一开始 默认是0 也就是 false 默认没有结束。</span><br><span class="line">        emit AuctionEnded(highestBidder, highestBid);</span><br><span class="line">        ended = true;                                // 锁住了。不能反复 给受益人打钱。</span><br><span class="line">        beneficiary.transfer(highestBid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这是一个“内部”函数，这意味着它只能从合约本身（或从派生合约）调用。</span><br><span class="line">    function placeBid(address bidder, uint value) internal</span><br><span class="line">            returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value &lt;= highestBid) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (highestBidder != address(0)) &#123;</span><br><span class="line">            // 退款给之前的最高出价者。</span><br><span class="line">            pendingReturns[highestBidder] += highestBid;</span><br><span class="line">        &#125;</span><br><span class="line">        highestBid = value;</span><br><span class="line">        highestBidder = bidder;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="远程购买"><a href="#远程购买" class="headerlink" title="远程购买"></a>远程购买</h2><p>双方必须将物品价值的两倍放入合约作为托管。 一旦发生状况，以太币将被锁定在合约中，直到买方确认他们收到了物品。 之后，买方将获得价值（他们存款的一半），而卖方将获得三倍的价值（他们的存款加上价值）。 其背后的想法是双方都有动力来解决这种情况，否则他们的以太币将永远被锁定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    uint public value;</span><br><span class="line">    address payable public seller;</span><br><span class="line">    address payable public buyer;</span><br><span class="line"></span><br><span class="line">    enum State &#123; Created, Locked, Release, Inactive &#125; // 定义一个枚举类</span><br><span class="line">    // 状态变量的默认值为第一个成员，`State.created`</span><br><span class="line">    State public state;</span><br><span class="line"></span><br><span class="line">    modifier condition(bool condition_) &#123;</span><br><span class="line">        require(condition_);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 只有买方可以调用此函数。</span><br><span class="line">    error OnlyBuyer();</span><br><span class="line">    /// 只有卖方可以调用此函数。</span><br><span class="line">    error OnlySeller();</span><br><span class="line">    /// 当前状态下无法调用该函数。</span><br><span class="line">    error InvalidState();</span><br><span class="line">    /// 提供的值必须是偶数。</span><br><span class="line">    error ValueNotEven();</span><br><span class="line"></span><br><span class="line">    modifier onlyBuyer() &#123;</span><br><span class="line">        if (msg.sender != buyer)</span><br><span class="line">            revert OnlyBuyer();</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123;</span><br><span class="line">        if (msg.sender != seller)</span><br><span class="line">            revert OnlySeller();</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier inState(State state_) &#123;</span><br><span class="line">        if (state != state_)</span><br><span class="line">            revert InvalidState();</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Aborted();</span><br><span class="line">    event PurchaseConfirmed();</span><br><span class="line">    event ItemReceived();</span><br><span class="line">    event SellerRefunded();</span><br><span class="line"></span><br><span class="line">    // 确保 `msg.value` 是一个偶数。</span><br><span class="line">    // 如果是奇数，除法将截断。</span><br><span class="line">    // 通过乘法检查它不是奇数。</span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        seller = payable(msg.sender);</span><br><span class="line">        value = msg.value / 2;</span><br><span class="line">        if ((2 * value) != msg.value)</span><br><span class="line">            revert ValueNotEven();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 中止购买并收回以太币。</span><br><span class="line">    /// 只能由卖方在合约被锁定之前调用。</span><br><span class="line">    function abort()</span><br><span class="line">        external</span><br><span class="line">        onlySeller</span><br><span class="line">        inState(State.Created)</span><br><span class="line">    &#123;</span><br><span class="line">        emit Aborted();</span><br><span class="line">        state = State.Inactive;</span><br><span class="line">        // 我们在这里直接使用转账。</span><br><span class="line">        // 可用于防止重入，因为它是此函数中的最后一个调用，我们已经改变了状态。</span><br><span class="line">        seller.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 作为买方确认购买。</span><br><span class="line">    /// 交易必须包括 `2 * value` 以太币。</span><br><span class="line">    /// 以太币将在调用 confirmReceived 之前被锁定。</span><br><span class="line">    function confirmPurchase()</span><br><span class="line">        external</span><br><span class="line">        inState(State.Created)</span><br><span class="line">        condition(msg.value == (2 * value))</span><br><span class="line">        payable</span><br><span class="line">    &#123;</span><br><span class="line">        emit PurchaseConfirmed();</span><br><span class="line">        buyer = payable(msg.sender);</span><br><span class="line">        state = State.Locked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 确认你（买方）收到了物品。</span><br><span class="line">    /// 这将释放锁定的以太币。</span><br><span class="line">    function confirmReceived()</span><br><span class="line">        external</span><br><span class="line">        onlyBuyer</span><br><span class="line">        inState(State.Locked)</span><br><span class="line">    &#123;</span><br><span class="line">        emit ItemReceived();</span><br><span class="line">        // 首先改变状态是很重要的，</span><br><span class="line">        // 否则，使用 `send` 调用的合约可以再次调用这里。</span><br><span class="line">        state = State.Release;</span><br><span class="line"></span><br><span class="line">        buyer.transfer(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 此函数退款给卖方，即退还卖方的锁定资金。</span><br><span class="line">    function refundSeller()</span><br><span class="line">        external</span><br><span class="line">        onlySeller</span><br><span class="line">        inState(State.Release)</span><br><span class="line">    &#123;</span><br><span class="line">        emit SellerRefunded();</span><br><span class="line">        // 首先改变状态是很重要的，</span><br><span class="line">        // 否则，使用 `send` 调用的合约可以再次调用这里。</span><br><span class="line">        state = State.Inactive;</span><br><span class="line"></span><br><span class="line">        seller.transfer(3 * value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="微支付通道"><a href="#微支付通道" class="headerlink" title="微支付通道"></a>微支付通道</h2><p>对于没有接触过区块链的人来说应该先看看下面这个通俗的解释来理解一下 【微支付通道】的意思；</p>
<h3 id="（一）通俗的例子（新人必看）"><a href="#（一）通俗的例子（新人必看）" class="headerlink" title="（一）通俗的例子（新人必看）"></a>（一）通俗的例子（新人必看）</h3><p>比喻场景：你去咖啡店喝咖啡（微支付通道）</p>
<p>你每天都去同一家咖啡店，点咖啡价格是 <strong>10 元</strong>。</p>
<p>但是——每次都用区块链支付太慢、太贵（Gas）。<br> 所以你和店主想出一个办法：<strong>先开一个“记账本”</strong>（通道），只在开始和结束时上链，中间的每一杯咖啡都离线结算。</p>
<hr>
<h4 id="🪙-第一步：开通通道（上链）"><a href="#🪙-第一步：开通通道（上链）" class="headerlink" title="🪙 第一步：开通通道（上链）"></a>🪙 第一步：开通通道（上链）</h4><p>你和咖啡店老板在区块链上签了一个“合约”：</p>
<blockquote>
<p>「我先在合约里存 100 元，代表我未来最多能喝 10 杯咖啡。」</p>
</blockquote>
<p>这笔 100 元是<strong>押金</strong>，写进区块链里。</p>
<hr>
<h4 id="✍️-第二步：离线签名（离链支付）"><a href="#✍️-第二步：离线签名（离链支付）" class="headerlink" title="✍️ 第二步：离线签名（离链支付）"></a>✍️ 第二步：离线签名（离链支付）</h4><p>你喝第一杯咖啡。<br> 老板要你“签个字”表示「我承认这杯咖啡花了 10 元」。</p>
<p>于是你写了一张<strong>签署的凭证</strong>：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我（客户）同意支付老板<span class="number"> 10 </span>元。</span><br><span class="line">签名：Yushao</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这张“签名凭证”不需要上链，只存在你和老板之间。</p>
</blockquote>
<p>喝第二杯时，你再写：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我同意支付老板<span class="number"> 20 </span>元。</span><br><span class="line">签名：Yushao</span><br></pre></td></tr></table></figure>

<p>表示：<strong>截止目前</strong>我欠他 20 元（累计的）。</p>
<blockquote>
<p>如果要加上一些复杂的参数来组装出签名的内容</p>
</blockquote>
<blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我欠 老板张三（recipient）的 钱（amount）是 20 元，</span><br><span class="line">凭证编号（nonce）是 3，</span><br><span class="line">这份凭证属于 合同号 #AABBCC（contractAddress）</span><br><span class="line">签名：Yushao</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="🔐-“签署内容”到底是什么？"><a href="#🔐-“签署内容”到底是什么？" class="headerlink" title="🔐 “签署内容”到底是什么？"></a>🔐 “签署内容”到底是什么？</h4><p>签署的不是“文字”，而是一段数据的哈希。<br> 但你可以把它理解成是对这句话签名：</p>
<blockquote>
<p>“如果这张单据（余额&#x3D;20元）是我签的，那我确实授权支付这么多。”</p>
</blockquote>
<p>老板收到后，他自己不能改成“余额&#x3D;30元”，因为那会导致签名验证失败。</p>
<p>✅ <strong>签名证明了你确实说过这句话。</strong></p>
<hr>
<h4 id="💡-第三步：通道结算（上链一次）"><a href="#💡-第三步：通道结算（上链一次）" class="headerlink" title="💡 第三步：通道结算（上链一次）"></a>💡 第三步：通道结算（上链一次）</h4><p>当你喝完最后一杯、或者不想继续喝了，<br> 老板把你最后一张“签名凭证”拿去链上：</p>
<blockquote>
<p>「链上合约，请根据这份签名支付我 50 元。」</p>
</blockquote>
<p>合约验证签名确实是你的 → 给老板转 50 元 → 把剩下的 50 元还你。<br> 整个过程中，<strong>只有两次上链</strong>：</p>
<ol>
<li>开通通道（存钱）</li>
<li>关闭通道（结算）</li>
</ol>
<p>中间那 10 次离线签名都没花 Gas。</p>
<h3 id="（二）官网的例子"><a href="#（二）官网的例子" class="headerlink" title="（二）官网的例子"></a>（二）官网的例子</h3><p>例子中使用加密签名，使以太币在同一当事人之间的重复转移变得安全、即时，并且没有交易费用。 </p>
<p>Alice想发送一些以太给Bob， 即Alice是发送方，Bob是接收方。</p>
<p>Alice 只需要在链下发送经过加密签名的信息 (例如通过电子邮件)给Bob，它类似于写支票。</p>
<p>Alice和Bob使用签名来授权交易，这在以太坊的智能合约中是可以实现的。 Alice将建立一个简单的智能合约，让她传输以太币，但她不会自己调用一个函数来启动付款， 而是让Bob来做，从而支付交易费用。</p>
<p>该合约将按以下方式运作：</p>
<ul>
<li><p>Alice部署了 ReceiverPays 合约，附加了足够的以太币来支付将要进行的付款。</p>
</li>
<li><p>Alice通过用她的私钥签署一个消息来授权付款。</p>
</li>
<li><p>Alice将经过加密签名的信息发送给Bob。该信息不需要保密（后面会解释），而且发送机制也不重要。</p>
</li>
<li><p>Bob通过向智能合约发送签名的信息来索取他的付款，合约验证了信息的真实性，然后释放资金。</p>
</li>
</ul>
<h4 id="创建签名"><a href="#创建签名" class="headerlink" title="创建签名"></a>创建签名</h4><p>Alice不需要与以太坊网络交互来签署交易，这个过程是完全离线的。 我们将使用 <a target="_blank" rel="noopener" href="https://github.com/web3/web3.js">web3.js</a> 和 <a target="_blank" rel="noopener" href="https://metamask.io/">MetaMask</a> 在浏览器中签署信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 先进行哈希运算使事情变得更容易</span></span><br><span class="line"><span class="keyword">var</span> hash = web3.<span class="property">utils</span>.<span class="title function_">sha3</span>(<span class="string">&quot;message to sign&quot;</span>);</span><br><span class="line">web3.<span class="property">eth</span>.<span class="property">personal</span>.<span class="title function_">sign</span>(hash, web3.<span class="property">eth</span>.<span class="property">defaultAccount</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signed&quot;</span>); &#125;);</span><br><span class="line"><span class="comment">/// web3.eth.personal.sign 把信息的长度加到签名数据中。 （这里是 web3.eth.defaultAccount）对 hash 进行签名。personal.sign 是 JSON-RPC personal_sign 的封装。签名会返回一个 signature（通常在 callback 的参数中），这里示例只打印 “Signed”。</span></span><br></pre></td></tr></table></figure>

<h4 id="签署内容"><a href="#签署内容" class="headerlink" title="签署内容"></a>签署内容</h4><p>对于履行付款的合约，签署的信息必须包括：</p>
<blockquote>
<ol>
<li>收件人的钱包地址。</li>
<li>要转移的金额。</li>
<li>重放攻击的保护。</li>
</ol>
</blockquote>
<p>重放攻击是指一个已签署的信息被重复使用，以获得对第二次交易的授权。 为了避免重放攻击，我们使用与以太坊交易本身相同的技术， 即所谓的nonce，它是一个账户发送的交易数量。 智能合约会检查一个nonce是否被多次使用。</p>
<p>另一种类型的重放攻击可能发生在所有者部署 <code>ReceiverPays</code> 合约时， 先进行了一些支付，然后销毁该合约。后来， 他们决定再次部署 <code>RecipientPays</code> 合约， 但新的合约不知道以前合约中使用的nonces，所以攻击者可以再次使用旧的信息。</p>
<h4 id="组装参数"><a href="#组装参数" class="headerlink" title="组装参数"></a>组装参数</h4><p>既然我们已经确定了要在签名信息中包含哪些信息， 我们准备把信息放在一起，进行哈希运算，然后签名。 简单起见，我们把数据连接起来。 <a target="_blank" rel="noopener" href="https://github.com/ethereumjs/ethereumjs-abi">ethereumjs-abi</a> 库提供了一个名为 <code>soliditySHA3</code> 的函数， 模仿Solidity的 <code>keccak256</code> 函数应用于使用 <code>abi.encodePacked</code> 编码的参数的行为。 这里有一个JavaScript函数，为 <code>ReceiverPays</code> 的例子创建了适当的签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// recipient， 是应该被支付的地址。</span><br><span class="line">// amount，单位是 wei, 指定应该发送多少ether。</span><br><span class="line">// nonce， 可以是任何唯一的数字，以防止重放攻击。</span><br><span class="line">// contractAddress， 用于防止跨合约的重放攻击。</span><br><span class="line">function signPayment(recipient, amount, nonce, contractAddress, callback) &#123;</span><br><span class="line">    var hash = &quot;0x&quot; + abi.soliditySHA3(</span><br><span class="line">        [&quot;address&quot;, &quot;uint256&quot;, &quot;uint256&quot;, &quot;address&quot;],</span><br><span class="line">        [recipient, amount, nonce, contractAddress]</span><br><span class="line">    ).toString(&quot;hex&quot;);</span><br><span class="line"></span><br><span class="line">    web3.eth.personal.sign(hash, web3.eth.defaultAccount, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>function signPayment(recipient, amount, nonce, contractAddress, callback) &#123;</code><br> 定义一个用于生成并签名“支付凭证”的函数，最后通过 <code>callback</code> 返回签名（或错误）。</p>
<p><code>var hash = &quot;0x&quot; + abi.soliditySHA3( ... ).toString(&quot;hex&quot;);</code><br> 这行是关键，分解如下：</p>
<ul>
<li><code>abi.soliditySHA3([...types...], [...values...])</code>：<br> 作用是按 <strong>Solidity 的 <code>abi.encodePacked</code> 编码规则</strong> 将值打包，然后对打包后的字节串做 keccak256（solidity 中的 <code>keccak256(abi.encodePacked(...))</code>）。它模仿 Solidity 中的行为，确保 JS 端生成的哈希与 Solidity 合约内预期一致。</li>
<li><code>.toString(&quot;hex&quot;)</code>：把 <code>abi.soliditySHA3</code> 返回的 Buffer 或二进制结果转为 hex 字符串（不带 <code>0x</code> 前缀）。<code>&quot;0x&quot; + ...</code>：在以太坊生态中，十六进制字符串通常带 <code>0x</code> 前缀，所以这里加上 <code>0x</code>，形成标准的 hex hash 字符串（例如 <code>0xabc123...</code>）。</li>
<li><code>personal.sign</code> 会<strong>在签名前再次加上 Ethereum 消息前缀</strong>（<code>\x19Ethereum Signed Message:\n$&#123;length&#125;</code>）并将 <code>length</code> 设置为你传入 <code>hash</code> 的长度（如果你传入的是 32 字节 hash，这个 length 是 32，签名的是前缀+32字节内容）。因此，签名者实际签的是 <code>prefixed(hash)</code>，不是“裸哈希”。这导致在合约里直接用 <code>ecrecover</code> 去验证 <code>keccak256(abi.encodePacked(...))</code> 的原始哈希 <strong>不会</strong>与 <code>personal.sign</code> 的签名直接对应，除非你在合约里也做同样的前缀处理（即用 <code>keccak256(&quot;\x19Ethereum Signed Message:\n32&quot; + hash)</code>）来重建签名时的消息摘要。或者，你可以用客户端签 <code>signTypedData</code>（EIP-712）来获得可被合约更方便校验的结构化签名。</li>
<li>callback 参数通常是 <code>(err, signature) =&gt; &#123; ... &#125;</code>，签名字符串格式通常是 65 字节并编码为 hex（<code>r</code> + <code>s</code> + <code>v</code>）。</li>
</ul>
</blockquote>
<h4 id="在Solidity中恢复信息签名者"><a href="#在Solidity中恢复信息签名者" class="headerlink" title="在Solidity中恢复信息签名者"></a>在Solidity中恢复信息签名者</h4><p>web3.js 产生的签名是 <code>r</code>, <code>s</code> 和 <code>v</code> 的拼接的， 所以第一步是把这些参数分开。您可以在客户端这样做， 但在智能合约内这样做意味着你只需要发送一个签名参数而不是三个。 将一个字节数组分割成它的组成部分是很麻烦的， 所以我们在 <code>splitSignature</code> 函数中使用 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/v0.8.23/assembly.html">inline assembly</a> 完成这项工作（本节末尾的完整合约中的第三个函数）。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><span class="line">contract ReceiverPays &#123;</span><br><span class="line">    address owner = msg.sender;</span><br><span class="line"></span><br><span class="line">    mapping(uint256 =&gt; bool) usedNonces;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) external &#123;</span><br><span class="line">        require(!usedNonces[nonce]);</span><br><span class="line">        usedNonces[nonce] = true;</span><br><span class="line"></span><br><span class="line">        // 这将重新创建在客户端上签名的信息。</span><br><span class="line">        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));</span><br><span class="line"></span><br><span class="line">        require(recoverSigner(message, signature) == owner);</span><br><span class="line"></span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 销毁合约并收回剩余的资金。</span><br><span class="line">    function shutdown() external &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 签名方法。</span><br><span class="line">    function splitSignature(bytes memory sig)</span><br><span class="line">        internal</span><br><span class="line">        pure</span><br><span class="line">        returns (uint8 v, bytes32 r, bytes32 s)</span><br><span class="line">    &#123;</span><br><span class="line">        require(sig.length == 65);</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 前32个字节，在长度前缀之后。</span><br><span class="line">            r := mload(add(sig, 32))</span><br><span class="line">            // 第二个32字节。</span><br><span class="line">            s := mload(add(sig, 64))</span><br><span class="line">            // 最后一个字节（下一个32字节的第一个字节）。</span><br><span class="line">            v := byte(0, mload(add(sig, 96)))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function recoverSigner(bytes32 message, bytes memory sig)</span><br><span class="line">        internal</span><br><span class="line">        pure</span><br><span class="line">        returns (address)</span><br><span class="line">    &#123;</span><br><span class="line">        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);</span><br><span class="line"></span><br><span class="line">        return ecrecover(message, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 构建一个前缀哈希值，以模仿 eth_sign 的行为。</span><br><span class="line">    function prefixed(bytes32 hash) internal pure returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/solidity/" rel="tag"># solidity</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/03/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%92%B8%E6%AF%9B/" rel="prev" title="撸毛">
                  <i class="fa fa-chevron-left"></i> 撸毛
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/08/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%B8%89%E6%98%8E%E6%B2%BB%E6%94%BB%E5%87%BBSanwich%20Attack%E5%92%8CMEV/" rel="next" title="三明治攻击Sanwich Attack和MEV">
                  三明治攻击Sanwich Attack和MEV <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈宇韶chenyushao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
